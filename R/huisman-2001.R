## Georges needs to add comments...

##' Model implementing "Huisman, J., and Weissing, F.J. (2001).
##' Biological conditions for oscillations and chaos generated by multispecies
##' competition. Ecology 82, 2682â€“2695..
##'
##' Test case...
##'
##' Warning: there are some dependent parameters here, and they won't
##' be updated until I sort out some sort of parameter hook.  Or I'll
##' just remove the ability to set parameters from the parmeters
##' object, which reduces the complexity a bit.
##'
##' So, what we need to have is a couple of "axes" for parameters to
##' vary over.  But the actual parameters underlying things are a
##' crazy matrix of values.
##' 
##' @title Huisman & Weissing 2001
##' @param r Intrinsic growth rate
##' @param m Mortality rate
##' @param D Resource turnover rate
##' @param S Supply rate
##' @param matrices Matrices generated by \code{huisman_matrices}
##' @author Georges Kunstler and Rich FitzJohn
##' @export
make_huisman_2001<- function(r=1, m=0.25, D=0.25, S=c(1, 1),
                             matrices=huisman_matrices()) {
  defaults <- list(r=r, m=m, D=D, S=S)
  parameters <- make_parameters(defaults, environment())
  n <- matrices$n
  k <- matrices$k
  K <- matrices$K
  C <- matrices$C

  dydt <- function(t, ode.y, x, ...) {
    i <- seq_len(k) # index to resources
    R <- ode.y[i]
    y <- ode.y[-i]

    # Equation 3
    min.p <- colMins(p(x, R))

    # Equation 1b and 1a, respectively:
    dRdt <- D * (S - R) - drop(C(x) %*% (y * min.p))
    dydt <- y * (min.p - m)
    c(dRdt, dydt)
  }

  ## Given traits 'x' and initial densities 'y', compute the
  ## equilibrium.  Return the equilibrium resource availability at the
  ## same time.
  equilibrium <- function(x, y, method="runsteady",
                          init_time=200,
                          max_time=1e5) {
    # Initial resources are set to 'S'
    ans <- equilibrium_(dydt, x, c(S, y), method, init_time, max_time)
    i <- seq_len(k) # index to resources
    list(R=ans[i], y=ans[-i])
  }

  run <- function(x, y, times) {
    y0 <- c(S, y)
    res <- lsoda_nolist(y0, times, dydt, x)
    i.t <- 1
    i.R <- seq(2,   length=k)
    i.y <- seq(k+2, length=n)
    list(t=res[,i.t], R=res[,i.R], y=res[,i.y])
  }

  # Equation 2 in the paper:
  p <- function(x, R) {
    r * R / (K(x) + R)
  }
  # Equation 4:
  Rstar <- function(x) {
    m * K(x) / (r - m)
  }

  # So, still no 'fitness' function here yet.  I guess it's dNdt, but
  # at equilibrium resource dynamics, which probably need providing.
  # Or if they're absent we could just run up from the initial
  # conditions.
  ret <- list(equilibrium  = equilibrium,
              run          = run,
              parameters   = parameters,
              # Lower level components that might be useful:
              n=n, k=k, K=K, C=C, p=p, Rstar=Rstar)
  class(ret) <- "model"
  ret
}

# I'd like to be able to switch between different functions for K and
# C, partly so that we can test the behaviour of the model against
# results in the paper.  The simplest way of doing this would be to
# allow arbitrary functions to be passed in as K(x) and C(x).  Or if
# matrices are passed in then build simple functions around these.
# Checking that the dimensions of the returned matrices is sensible is
# an additional complication, but possibly one that can be ignored for
# now.

##' K(x) -> generates a matrix where each column is a species, and
##' each row is a resource.  It's set up so that the performance on
##' one resource is inversely related to the performance on the second
##' resource.  As such, 'x' entirely determines a species (at least
##' for now).
##' 
##' @rdname make_huisman_2001
##' @export
##' @param x (For \code{husiman_K_2} and \code{husiman_C_2}); species
##' trait values, on a scale of 0 to 1 (not checked).
huisman_mat_2 <- function(x) {
  rbind(x, 1-x, deparse.level=0)
}

##' @param K, C functions that generate matrices K and C (see the
##' paper) or matrices themselves.  If these are functions, then they
##' must take exactly one argument 'x': this argument is used nowhere
##' except for these two functions, but will be accepted by \code{run}
##' and \code{equilibrium}.
##' @rdname make_huisman_2001
##' @export
huisman_matrices <- function(K=huisman_mat_2, C=huisman_mat_2) {
  # Lots of different ways that this can be done, so just taking the
  # easy way our for now.
  if (is.matrix(K)) {
    if (!is.matrix(C) || !identical(dim(K), dim(C))) {
      stop("C must be a matrix with the same dimensions as K")
    }
    matrices <- list(K=function(x) K, C=function(x) C,
                     n=ncol(K), k=row(K))
  } else if (identical(K, huisman_mat_2)) {
    if (!identical(C, huisman_mat_2)) {
      stop("Invalid values for C")
    }
    # Currently the only dramas are:
    #   K() is hard coded for two resources
    #   C() is hard coded to be the same as K()
    # So we should now be good to go with an arbitrary number of
    # species on 2 resources.  So for now, we restrict to two
    # resources.
    matrices <- list(K=K, C=C, n=2L, k=2L)
  } else {
    stop("Invalid values for K")
  }
  matrices
}
