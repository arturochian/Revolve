## Georges needs to add comments...

##' Model implementing "Huisman, J., and Weissing, F.J. (2001).
##' Biological conditions for oscillations and chaos generated by multispecies
##' competition. Ecology 82, 2682-2695."
##'
##' Test case...
##'
##' Warning: there are some dependent parameters here, and they won't
##' be updated until I sort out some sort of parameter hook.  Or I'll
##' just remove the ability to set parameters from the parmeters
##' object, which reduces the complexity a bit.
##'
##' So, what we need to have is a couple of "axes" for parameters to
##' vary over.  But the actual parameters underlying things are a
##' crazy matrix of values.
##'
##' @title Huisman & Weissing 2001
##' @param r Intrinsic growth rate
##' @param m Mortality rate
##' @param D Resource turnover rate
##' @param S Supply rate
##' @param matrices Matrices generated by \code{huisman_matrices}
##' @author Georges Kunstler and Rich FitzJohn
##' @export
make_huisman_2001<- function(matrices, r=1, m=0.25, D=0.25, S=1) {
  defaults <- list(r=r, m=m, D=D, S=S)
  parameters <- make_parameters(defaults, environment())
  n <- matrices$n
  k <- matrices$k
  K <- matrices$K
  C <- matrices$C
  if (length(S) == 1) {
    S <- rep(S, k)
  } else if (length(S) != k) {
    stop("Invalid length S")
  }
  i.R <- seq_len(k)

  derivs <- function(t, ode.y, x, ...) {
    R <- ode.y[i.R]
    y <- ode.y[-i.R]
    c(dRdt(R, y, x),
      dydt(R, y, x))
  }
  derivs_R <- function(t, R, xy, ...) {
    dRdt(R, xy$y, xy$x)
  }

  # Equation 1b
  dRdt <- function(R, y, x) {
    D * (S - R) - drop(C(x) %*% (y * colMins(p(x, R))))
  }
  # Equation 1a
  dydt <- function(R, y, x) {
    y * (min.p(x, R) - m)
  }
  # Equation 3
  min.p <- function(x, R) {
    colMins(p(x, R))
  }

  # For fitness we want the *per-capita growth rate*; that is (min.p -
  # m), rather than y * (min.p - m).  We can't just divide by y
  # because we want it when y = 0 (rather than just being close).  For
  # now, I think we can just fake it by repeating a bunch of the
  # stuff.
  #
  # The issue that we have in terms of interface is that this doesn't
  # really depend on {x,y} as such, but on 'R', which is itself
  # determined by {x,y}.  So this function allows any R to be plugged
  # in, and if none is given we compute the equilibrium resource
  # density *holding density y constant*.
  fitness <- function(x_new, x, y, R=NULL) {
    if (is.null(R)) {
      if (length(y) != 1) {
        stop("Only works on a single species at the moment")
      }
      R <- single_equilibrium_R(x, y)
    }
    min.p(x_new, R) - m
  }

  # So what we want to do now is to break the model a bit and say
  # "holding this density of individuals, compute what the equilibrium
  # resource level is".  This is an odd thing to be doing, because
  # it's out of equilibrium (the density is too high or too low) but
  # we need it for a bunch of stuff.
  #
  run_fixed_density <- function(x, y, times, R0=S) {
    res <- lsoda_nolist(R0, times, derivs_R, list(x=x, y=y))
    list(t=times, R=res[,-1])
  }

  ## Given traits 'x' and initial densities 'y', compute the
  ## equilibrium.  Return the equilibrium resource availability at the
  ## same time.
  equilibrium <- function(x, y, method="runsteady",
                          init_time=200,
                          max_time=1e5) {
    res <- equilibrium_(derivs, x, initial.conditions(y),
                        method, init_time, max_time)
    list(R=res[i.R], y=res[-i.R])
  }

  ## Given traits 'x' and initial densities 'y', compute the
  ## equilibrium.  Return the equilibrium resource availability at the
  ## same time.
  equilibrium_R <- function(x, y, R0=S, method="runsteady",
                            init_time=200, max_time=1e-5) {
    res <- equilibrium_(derivs_R, list(x=x, y=y), R0,
                        method, init_time, max_time)
    list(R=res)
  }

  run <- function(x, y, times) {
    res <- lsoda_nolist(initial.conditions(y), times, derivs, x)[,-1,drop=FALSE]
    list(t=times, R=res[,i.R], y=res[,-i.R])
  }

  initial.conditions <- function(y0) {
    if (!is.na(n) && length(y0) != n) {
      stop("Invalid length initial conditions")
    }
    c(S, y0)
  }

  # Equation 2 in the paper:
  p <- function(x, R) {
    r * R / (K(x) + R)
  }
  # Equation 4:
  # This has the same orientation as K: each row is a resource, each
  # column is a species.
  Rstar <- function(x) {
    m * K(x) / (r - m)
  }

  # This is based on the solution to equation 1b = 0, given R*.
  single_equilibrium <- function(x) {
    R <- Rstar(x)
    if (ncol(R) != 1) {
      stop("Only valid for one species")
    }

    # Density when limited by each resource:
    y <- D * (S - R) / (C(x) *  p(x, R))
    if (nrow(R) == 1) { # 1 resource - R is at equilibrium
    } else if (nrow(R) == 2) { # 2 resource
      c.slope <- C(x)[2,1] / C(x)[1,1] # == (1 - x) / x
      if (S[2] > S[1] * c.slope) { # Limited by R1, so compute R2:
        R[2] <- S[2] - (S[1] - R[1]) * c.slope
        y <- y[1]
      } else { # Limited by R2, so compute R1:
        R[1] <- S[1] - (S[2] - R[2]) / c.slope
        y <- y[2]
      }
    } else {
      stop("Not yet implemented")
      # Something like this would work -- work out all possible moves
      # and take shortest line.  It should generalise out OK.
      #   dS <- S - R[,1]
      #   dy <- c(dS[1] * c.slope, dS[2])
      #   dx <- c(dS[1], dS[2] / c.slope)
      #   i <- which.min(dx^2 + dy^2)
      #   eq <- S - c(dx[i], dy[i])
    }

    list(R=drop(R), y=drop(y))
  }

  # Solve for the equilibrium level of a resource, given a vector of
  # densities (and species traits).  Do do this, we solve dRdt == 0:
  #    D (S - R) - c y p(R) == 0
  #    D * (S - R) - c y r R / (K + R) == 0
  # As a quadratic with respect to "R":
  #    -D * R^2 + (D (S - K) - c r y) * R + D K S == 0
  single_equilibrium_R <- function(x, y, R0=S, force.numerical=FALSE) {
    if (k == 1 && !force.numerical) {
      K <- K(x)
      C <- C(x)
      ans <- quadratic_roots(-D, (D * (S - K) - C * r * y), D * K * S)
      ans <- ans[ans >= 0 & ans <= S]
      if (length(ans) != 1) {
        stop("Did not find a unique solution")
      }
      ans
    } else {
      equilibrium_R(x, y, R0, "nleqslv")$R
    }
  }

  # So, still no 'fitness' function here yet.  I guess it's dNdt, but
  # at equilibrium resource dynamics, which probably need providing.
  # Or if they're absent we could just run up from the initial
  # conditions.
  ret <- list(fitness = fitness,
              equilibrium  = equilibrium,
              run          = run,
              parameters   = parameters,
              # Lower level components that might be useful:
              n=n, k=k, K=K, C=C, p=p, Rstar=Rstar,
              single_equilibrium=single_equilibrium,
              single_equilibrium_R=single_equilibrium_R,
              run_fixed_density=run_fixed_density,
              equilibrium_R=equilibrium_R)
  class(ret) <- "model"
  ret
}

# I'd like to be able to switch between different functions for K and
# C, partly so that we can test the behaviour of the model against
# results in the paper.  The simplest way of doing this would be to
# allow arbitrary functions to be passed in as K(x) and C(x).  Or if
# matrices are passed in then build simple functions around these.

# For a single resouce case, there is a single trivial non-constant
# function:

##' @export
##' @rdname make_huisman_2001
##' @param k number of resources
##' @param x matrix of traits (for the \code{huisman_mat_} functions).
make_huisman_identity <- function(k) {
  ret <- function(x) {
    if (!(is.matrix(x) && nrow(x) == k)) {
      stop("x must be a matrix with ", k, " rows")
    }
    x
  }
  attr(ret, "n") <- k
  ret
}

##' @export
##' @rdname make_huisman_2001
huisman_mat_1 <- make_huisman_identity(1L)
##' @export
##' @rdname make_huisman_2001
huisman_mat_2 <- make_huisman_identity(2L)

##' @export
##' @rdname make_huisman_2001
huisman_mat_2_tradeoff <- function(x) {
  rbind(x, 1-x, deparse.level=0)
}
attr(huisman_mat_2_tradeoff, "n") <- 1

##' @export
##' @rdname make_huisman_2001
##' @param M coumn matrix with K or C matrix that will be shared by
##' all species.
make_huisman_mat_constant <- function(M) {
  if (!is.matrix(M) || ncol(M) != 1) {
    stop("M must be a single column matrix")
  }
  ret <- function(x) {
    matrix(M, nrow=nrow(M), ncol=ncol(x))
  }
  attr(ret, "n") <- 0
  ret
}

##' @export
##' @rdname make_huisman_2001
##' @param K Matrix of Monod constants
##' @param C Matrix of consumption constants
huisman_matrices_fixed <- function(K, C) {
  if (!is.matrix(K) || !is.matrix(C)) {
    stop("K and C must both be matrices")
  }
  if (!identical(dim(K), dim(C))) {
    stop("K and C must have the same dimensions")
  }
  # Note that this does not use make_huisman_mat_constant because
  # these matrices are constant with respect to both the number of
  # resources *and* the number of species.  This exists only for
  # checking against the paper.
  matrices <- list(K=function(x) K, C=function(x) C,
                   n=ncol(K), k=nrow(K),
                   i.K=integer(0), i.C=integer(0))
}


##' @export
##' @rdname make_huisman_2001
huisman_matrices <- function(K, C) {
  if (is.matrix(K)) {
    huisman_matrices(make_huisman_mat_constant(K), C)
  } else if (is.matrix(C)) {
    huisman_matrices(K, make_huisman_mat_constant(C))
  } else {
    n.K <- get_attribute(K, "n")
    n.C <- get_attribute(C, "n")
    i.K <- seq_len(n.K)
    i.C <- seq_len(n.C) + n.K
    # Number of resouces, computed with dummy vector
    k <- nrow(K(matrix(rep(0.5, n.K), n.K, 1)))
    if (nrow(C(matrix(rep(0.5, n.C), n.C, 1))) != k) {
      stop("K and C disagree on k")
    }
    list(K=function(x) K(x[i.K,,drop=FALSE]),
         C=function(x) C(x[i.C,,drop=FALSE]),
         n=NA, k=k, i.K=i.K, i.C=i.C)
  }
}
##' Plot Huisman ZNGIs
##'
##' Will change
##' @title Plot Huisman ZNGIs
##' @param m Huisman model, made by \code{make_huisman}
##' @param x Matrix of parameters indicating species traits
##' @param xlim X axis limits (resource 1)
##' @param ylim Y axis limits (resource 2)
##' @param col Vector of colours along species
##' @author Rich FitzJohn
##' @export
huisman_plot <- function(m, x, xlim=c(0, 1), ylim=c(0, 1),
                         col=seq_len(ncol(x))) {
  if (m$k != 2) {
    stop("Can only plot 2 resource case at the moment")
  }
  n <- ncol(x)
  col <- rep(col, length.out=n)

  rs <- m$Rstar(x)
  plot(NA, xlim=xlim, ylim=ylim, xlab="R1", ylab="R2")
  abline(v=rs[1,], lty=3, col=col)
  abline(h=rs[2,], lty=3, col=col)
  segments(rs[1,], rs[2,], rs[1,], par("usr")[4], col=col)
  segments(rs[1,], rs[2,], par("usr")[2], rs[2,], col=col)

  R.eq <- apply(rs, 1, max)
  # This only makes sense for some cases?
  points(R.eq[1], R.eq[2], pch=19)

  C <- m$C(x)
  for (i in seq_len(n)) {
    abcline(R.eq[1], R.eq[2], C[2,i] / C[1,i], col=col[i], lty=2)
  }
}

##' @export
##' @rdname huisman_plot
##' @param y Densities of the species
##' @param eps Density at which species are considered extinct
##' @param t_max Maximum time to run simulation until
##' @param t_len Number of time intervals to run simulation over
##' @param S Resource supply rates (and initial resource levels)
##' @param col_died Colour of communities that go extinct.
huisman_trajectory <- function(m, x, y=rep(1, ncol(x)),
                               col=seq_len(ncol(x)), eps=1e-6,
                               t_max=100, t_len=101, S=NULL,
                               col_died="grey") {
  if (ncol(x) > 2) {
    stop("Only working for up to two species so far")
  }
  
  t <- seq(0, t_max, length.out=t_len)

  if (!is.null(S)) {
    if (length(S) != m$k)
      stop("Invalid length S")
    op <- m$parameters$set(list(S=S))
    on.exit(m$parameters$set(op))
  }

  eq <- m$equilibrium(x, y)
  tr <- m$run(x, y, t)
  S <- m$parameters$get()[["S"]]

  survived <- eq$y > 1e-6

  if (sum(survived) == 1) {
    col <- col[which(survived)]
  } else if (sum(survived) == 2) {
    col <- mix(col[1], col[2])
  } else {
    col <- col_died
  }

  lines(tr$R[,1], tr$R[,2], lty=2, col=col)
  points(c(S[1], eq$R[1]),
         c(S[2], eq$R[2]), pch=19, col=col, cex=.5)
}
