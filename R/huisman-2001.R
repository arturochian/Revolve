## Georges needs to add comments...

##' Model implementing "Huisman, J., and Weissing, F.J. (2001).
##' Biological conditions for oscillations and chaos generated by multispecies
##' competition. Ecology 82, 2682-2695."
##'
##' Test case...
##'
##' Warning: there are some dependent parameters here, and they won't
##' be updated until I sort out some sort of parameter hook.  Or I'll
##' just remove the ability to set parameters from the parmeters
##' object, which reduces the complexity a bit.
##'
##' So, what we need to have is a couple of "axes" for parameters to
##' vary over.  But the actual parameters underlying things are a
##' crazy matrix of values.
##'
##' @title Huisman & Weissing 2001
##' @param r Intrinsic growth rate
##' @param m Mortality rate
##' @param D Resource turnover rate
##' @param S Supply rate
##' @param matrices Matrices generated by \code{huisman_matrices}
##' @author Georges Kunstler and Rich FitzJohn
##' @export
make_huisman_2001<- function(r=1, m=0.25, D=0.25, S=1,
                             matrices=huisman_matrices()) {
  defaults <- list(r=r, m=m, D=D, S=S)
  parameters <- make_parameters(defaults, environment())
  n <- matrices$n
  k <- matrices$k
  K <- matrices$K
  C <- matrices$C
  if (length(S) == 1) {
    S <- rep(S, k)
  } else if (length(S) != k) {
    stop("Invalid length S")
  }
  i.R <- seq_len(k)

  derivs <- function(t, ode.y, x, ...) {
    R <- ode.y[i.R]
    y <- ode.y[-i.R]
    c(dRdt(R, y, x),
      dydt(R, y, x))
  }
  derivs_R <- function(t, R, xy, ...) {
    dRdt(R, xy$y, xy$x)
  }

  # Equation 1b
  dRdt <- function(R, y, x) {
    D * (S - R) - drop(C(x) %*% (y * colMins(p(x, R))))
  }
  # Equation 1a
  dydt <- function(R, y, x) {
    y * (min.p(x, R) - m)
  }
  # Equation 3
  min.p <- function(x, R) {
    colMins(p(x, R))
  }

  # For fitness we want the *per-capita growth rate*; that is (min.p -
  # m), rather than y * (min.p - m).  We can't just divide by y
  # because we want it when y = 0 (rather than just being close).  For
  # now, I think we can just fake it by repeating a bunch of the
  # stuff.
  #
  # The issue that we have in terms of interface is that this doesn't
  # really depend on {x,y} as such, but on 'R', which is itself
  # determined by {x,y}.  So this function allows any R to be plugged
  # in, and if none is given we compute the equilibrium resource
  # density *holding density y constant*.
  fitness <- function(x_new, x, y, R=NULL) {
    if (is.null(R)) {
      if (length(y) != 1) {
        stop("Only works on a single species at the moment")
      }
      R <- single_equilibrium_R(x, y)
    }
    min.p(x_new, R) - m
  }

  # So what we want to do now is to break the model a bit and say
  # "holding this density of individuals, compute what the equilibrium
  # resource level is".  This is an odd thing to be doing, because
  # it's out of equilibrium (the density is too high or too low) but
  # we need it for a bunch of stuff.
  #
  run_fixed_density <- function(x, y, times, R0=S) {
    res <- lsoda_nolist(R0, times, derivs_R, list(x=x, y=y))
    list(t=times, R=res[,-1])
  }

  ## Given traits 'x' and initial densities 'y', compute the
  ## equilibrium.  Return the equilibrium resource availability at the
  ## same time.
  equilibrium <- function(x, y, method="runsteady",
                          init_time=200,
                          max_time=1e5) {
    res <- equilibrium_(derivs, x, initial.conditions(y),
                        method, init_time, max_time)
    list(R=res[i.R], y=res[-i.R])
  }

  ## Given traits 'x' and initial densities 'y', compute the
  ## equilibrium.  Return the equilibrium resource availability at the
  ## same time.
  equilibrium_R <- function(x, y, R0=S, method="runsteady",
                            init_time=200, max_time=1e-5) {
    res <- equilibrium_(derivs_R, list(x=x, y=y), R0,
                        method, init_time, max_time)
    list(R=res)
  }

  run <- function(x, y, times) {
    res <- lsoda_nolist(initial.conditions(y), times, derivs, x)[,-1,drop=FALSE]
    list(t=times, R=res[,i.R], y=res[,-i.R])
  }

  initial.conditions <- function(y0) {
    if (!is.na(n) && length(y0) != n) {
      stop("Invalid length initial conditions")
    }
    c(S, y0)
  }

  # Equation 2 in the paper:
  p <- function(x, R) {
    r * R / (K(x) + R)
  }
  # Equation 4:
  # This has the same orientation as K: each row is a resource, each
  # column is a species.
  Rstar <- function(x) {
    m * K(x) / (r - m)
  }

  # This is based on the solution to equation 1b = 0, given R*.
  single_equilibrium <- function(x) {
    R <- Rstar(x)
    if (ncol(R) != 1) {
      stop("Only valid for one species")
    }

    # Density when limited by each resource:
    y <- D * (S - R) / (C(x) *  p(x, R))
    if (nrow(R) == 1) { # 1 resource - R is at equilibrium
    } else if (nrow(R) == 2) { # 2 resource
      c.slope <- C(x)[2,1] / C(x)[1,1] # == (1 - x) / x
      if (S[2] > S[1] * c.slope) { # Limited by R1, so compute R2:
        R[2] <- S[2] - (S[1] - R[1]) * c.slope
        y <- y[1]
      } else { # Limited by R2, so compute R1:
        R[1] <- S[1] - (S[2] - R[2]) / c.slope
        y <- y[2]
      }
    } else {
      stop("Not yet implemented")
      # Something like this would work -- work out all possible moves
      # and take shortest line.  It should generalise out OK.
      #   dS <- S - R[,1]
      #   dy <- c(dS[1] * c.slope, dS[2])
      #   dx <- c(dS[1], dS[2] / c.slope)
      #   i <- which.min(dx^2 + dy^2)
      #   eq <- S - c(dx[i], dy[i])
    }

    list(R=drop(R), y=drop(y))
  }

  # Solve for the equilibrium level of a resource, given a vector of
  # densities (and species traits).  Do do this, we solve dRdt == 0:
  #    D (S - R) - c y p(R) == 0
  #    D * (S - R) - c y r R / (K + R) == 0
  # As a quadratic with respect to "R":
  #    -D * R^2 + (D (S - K) - c r y) * R + D K S == 0
  single_equilibrium_R <- function(x, y, R0=S, force.numerical=FALSE) {
    if (k == 1 && !force.numerical) {
      K <- K(x)
      C <- C(x)
      ans <- quadratic_roots(-D, (D * (S - K) - C * r * y), D * K * S)
      ans <- ans[ans >= 0 & ans <= S]
      if (length(ans) != 1) {
        stop("Did not find a unique solution")
      }
      ans
    } else {
      equilibrium_R(x, y, R0, "nleqslv")$R
    }
  }

  # So, still no 'fitness' function here yet.  I guess it's dNdt, but
  # at equilibrium resource dynamics, which probably need providing.
  # Or if they're absent we could just run up from the initial
  # conditions.
  ret <- list(fitness = fitness,
              equilibrium  = equilibrium,
              run          = run,
              parameters   = parameters,
              # Lower level components that might be useful:
              n=n, k=k, K=K, C=C, p=p, Rstar=Rstar,
              single_equilibrium=single_equilibrium,
              single_equilibrium_R=single_equilibrium_R,
              run_fixed_density=run_fixed_density,
              equilibrium_R=equilibrium_R)
  class(ret) <- "model"
  ret
}

# I'd like to be able to switch between different functions for K and
# C, partly so that we can test the behaviour of the model against
# results in the paper.  The simplest way of doing this would be to
# allow arbitrary functions to be passed in as K(x) and C(x).  Or if
# matrices are passed in then build simple functions around these.
# Checking that the dimensions of the returned matrices is sensible is
# an additional complication, but possibly one that can be ignored for
# now.

##' K(x) -> generates a matrix where each column is a species, and
##' each row is a resource.  It's set up so that the performance on
##' one resource is inversely related to the performance on the second
##' resource.  As such, 'x' entirely determines a species (at least
##' for now).
##'
##' @rdname make_huisman_2001
##' @export
##' @param x (For \code{husiman_K_2} and \code{husiman_C_2}); species
##' trait values, on a scale of 0 to 1 (not checked).
huisman_mat_2 <- function(x) {
  rbind(x, 1-x, deparse.level=0)
}

##' @param K function that generate the K matrix (see the paper) or
##' the K matrix itself.  If this is a function, then they must take
##' exactly one argument 'x': this argument is used nowhere except for
##' these two functions, but will be accepted by \code{run} and
##' \code{equilibrium}.
##' @param C as for K, but for the C matrix.
##' @rdname make_huisman_2001
##' @export
huisman_matrices <- function(K=huisman_mat_2, C=NULL) {
  # Lots of different ways that this can be done, so just taking the
  # easy way our for now.
  if (is.matrix(K)) {
    if (!is.matrix(C) || !identical(dim(K), dim(C))) {
      stop("C must be a matrix with the same dimensions as K")
    }
    matrices <- list(K=function(x) K, C=function(x) C,
                     n=ncol(K), k=nrow(K))
  } else if (identical(K, huisman_mat_1)) {
    K <- function(x) huisman_mat_1(x, 1)
    C <- function(x) huisman_mat_1(x, 2)
    matrices <- list(K=K, C=C, n=NA, k=1L)
  } else if (identical(K, huisman_mat_2)) {
    if (!is.null(C)) {
      stop("Invalid values for C")
    }
    matrices <- list(K=K, C=K, n=NA, k=2L)
  } else {
    stop("Invalid values for K")
  }
  matrices
}

##' @param i Internally used (but is 1 for K, 2 for C).
##' @export
##' @rdname make_huisman_2001
huisman_mat_1 <- function(x, i) {
  x[i,,drop=FALSE]
}
