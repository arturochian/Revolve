## Georges needs to add comments...

##' Model implementing "Huisman, J., and Weissing, F.J. (2001).
##' Biological conditions for oscillations and chaos generated by multispecies
##' competition. Ecology 82, 2682-2695.
##'
##' Test case...
##'
##' Warning: there are some dependent parameters here, and they won't
##' be updated until I sort out some sort of parameter hook.  Or I'll
##' just remove the ability to set parameters from the parmeters
##' object, which reduces the complexity a bit.
##'
##' So, what we need to have is a couple of "axes" for parameters to
##' vary over.  But the actual parameters underlying things are a
##' crazy matrix of values.
##' 
##' @title Huisman & Weissing 2001
##' @param r Intrinsic growth rate
##' @param m Mortality rate
##' @param D Resource turnover rate
##' @param S Supply rate
##' @param matrices Matrices generated by \code{huisman_matrices}
##' @author Georges Kunstler and Rich FitzJohn
##' @export
make_huisman_2001<- function(r=1, m=0.25, D=0.25, S=1,
                             matrices=huisman_matrices()) {
  defaults <- list(r=r, m=m, D=D, S=S)
  parameters <- make_parameters(defaults, environment())
  n <- matrices$n
  k <- matrices$k
  K <- matrices$K
  C <- matrices$C
  if (length(S) == 1) {
    S <- rep(S, k)
  } else if (length(S) != k) {
    stop("Invalid length S")
  }
  i.R <- seq_len(k)

  dydt <- function(t, ode.y, x, ...) {
    R <- ode.y[i.R]
    y <- ode.y[-i.R]

    # Equation 3
    min.p <- colMins(p(x, R))

    # Equation 1b and 1a, respectively:
    dRdt <- D * (S - R) - drop(C(x) %*% (y * min.p))
    dydt <- y * (min.p - m)
    c(dRdt, dydt)
  }

  ## Given traits 'x' and initial densities 'y', compute the
  ## equilibrium.  Return the equilibrium resource availability at the
  ## same time.
  equilibrium <- function(x, y, method="runsteady",
                          init_time=200,
                          max_time=1e5) {
    res <- equilibrium_(dydt, x, initial.conditions(y),
                        method, init_time, max_time)
    list(R=res[i.R], y=res[-i.R])
  }

  run <- function(x, y, times) {
    res <- lsoda_nolist(initial.conditions(y), times, dydt, x)[,-1,drop=FALSE]
    list(t=times, R=res[,i.R], y=res[,-i.R])
  }

  initial.conditions <- function(y0) {
    if (!is.na(n) && length(y0) != n) {
      stop("Invalid length initial conditions")
    }
    c(S, y0)
  }

  # Equation 2 in the paper:
  p <- function(x, R) {
    r * R / (K(x) + R)
  }
  # Equation 4:
  Rstar <- function(x) {
    m * K(x) / (r - m)
  }

  # So, still no 'fitness' function here yet.  I guess it's dNdt, but
  # at equilibrium resource dynamics, which probably need providing.
  # Or if they're absent we could just run up from the initial
  # conditions.
  ret <- list(equilibrium  = equilibrium,
              run          = run,
              parameters   = parameters,
              # Lower level components that might be useful:
              n=n, k=k, K=K, C=C, p=p, Rstar=Rstar)
  class(ret) <- "model"
  ret
}

# I'd like to be able to switch between different functions for K and
# C, partly so that we can test the behaviour of the model against
# results in the paper.  The simplest way of doing this would be to
# allow arbitrary functions to be passed in as K(x) and C(x).  Or if
# matrices are passed in then build simple functions around these.
# Checking that the dimensions of the returned matrices is sensible is
# an additional complication, but possibly one that can be ignored for
# now.

##' K(x) -> generates a matrix where each column is a species, and
##' each row is a resource.  It's set up so that the performance on
##' one resource is inversely related to the performance on the second
##' resource.  As such, 'x' entirely determines a species (at least
##' for now).
##' 
##' @rdname make_huisman_2001
##' @export
##' @param x (For \code{husiman_K_2} and \code{husiman_C_2}); species
##' trait values, on a scale of 0 to 1 (not checked).
huisman_mat_2 <- function(x) {
  rbind(x, 1-x, deparse.level=0)
}

##' @param K function that generate the K matrix (see the paper) or
##' the K matrix itself.  If this is a function, then they must take
##' exactly one argument 'x': this argument is used nowhere except for
##' these two functions, but will be accepted by \code{run} and
##' \code{equilibrium}.
##' @param C as for K, but for the C matrix.
##' @rdname make_huisman_2001
##' @export
huisman_matrices <- function(K=huisman_mat_2, C=huisman_mat_2) {
  # Lots of different ways that this can be done, so just taking the
  # easy way our for now.
  if (is.matrix(K)) {
    if (!is.matrix(C) || !identical(dim(K), dim(C))) {
      stop("C must be a matrix with the same dimensions as K")
    }
    matrices <- list(K=function(x) K, C=function(x) C,
                     n=ncol(K), k=nrow(K))
  } else if (identical(K, huisman_mat_2)) {
    if (!identical(C, huisman_mat_2)) {
      stop("Invalid values for C")
    }
    matrices <- list(K=K, C=C, n=NA, k=2L)
  } else {
    stop("Invalid values for K")
  }
  matrices
}
